### c语言内存模型

1. 栈溢出：栈溢出是指当程序在栈上分配的内存空间超过栈的实际大小时所发生的错误情况。

2. 堆区和栈区的区别：堆区由程序员手动分配与释放内存，内存空间较大但是分配速度较慢。栈区由系统自动管理内存的分配和释放，分配速度快但是内存较小。另外堆区的数据的存储位置是不连续的，分配的内存块可能分散在不同的地址空间，栈区的数据的存储位置是连续的，按照函数调用的顺序依次入栈和出栈。

3. 只读：程序代码区，常量区。可读写：全局数据区，堆区，栈区。

4. `malloc()`和`free()`函数主要针对堆区进行操作：首先需要包含<`stdlib.h`>头文件，具体用法：`void *malloc(size_t size)`; `void free(void *ptr)`;

5. 为什么要对程序使用的内存进行管理？：提高资源利用率，防止内存泄漏，避免内存碎片，提高程序稳定性，实现动态内存分配。

   ### 内存模型的应用

   1. `constValue`：存储在常量存储区。因为它是一个常量整数，常量通常存储在常量存储区，以确保其在程序运行期间不能被修改。如果其不在常量区，则在程序运行过程中，其有可能会被修改，导致程序运行结果出错或者崩溃。

   2. `constString`：存储在常量存储区。字符串常量被存储在常量存储区，同样不能被修改。如果其不在常量区，则在程序运行过程中，其有可能会被修改，导致程序运行结果出错或者崩溃。

   3. `globalVar`：存储在全局数据区（静态存储区）。全局变量在程序启动时分配内存，在整个程序运行期间都存在，所以存储在全局数据区。如果储存在其它区域，可能会导致其在某些函数中不可用。

   4. `staticVar`：存储在全局数据区（静态存储区）。静态变量在程序启动时分配内存，并且在整个程序运行期间都存在，所以也存储在全局数据区。如果储存在栈区，则其在`main`函数结束后，其值会消失。

   5. `localVar`（函数中的局部变量）：存储在栈区。局部变量通常在函数调用时在栈上分配内存，函数执行完毕后自动释放。如果在堆区，其没有手动释放内存，会导致程序崩溃。

   6. `ptr`：是一个指针变量，存储在栈区。但是它指向的内存是通过`malloc`在堆区分配的。

   7. `localVarMain`：存储在栈区。和其他局部变量一样，在函数`main`调用时在栈上分配内存，函数执行完毕后自动释放。

      ### 浅谈Cache

      1. 什么是冯诺伊曼体系结构？什么是现代计算机的组织结构？这两者的不同点在哪里？：冯诺依曼体系结构是一种将程序指令存储器和数据存储器合并在一起的计算机设计概念，由运算器、控制器、存储器、输入设备和输出设备五大部件组成。现代计算机通常在冯诺依曼体系结构的基础上进行了扩展和优化，使用了多级存储体系，并行处理结构等。两者在存储体系，处理能力，输入与输出设备上不同

      2. 主存储器是如何工作的？：存储数据：数据以二进制形式存储在存储单元中，每个存储单元都有一个唯一的地址。当需要存储数据时，通过地址总线将地址信息发送到存储器，然后通过数据总线将数据写入相应的存储单元。读取数据：当需要读取数据时，同样通过地址总线发送地址信息，存储器根据地址找到相应的存储单元，并将其中的数据通过数据总线发送回处理器。

      3. 什么是Cache的局部性原理？它包括哪些方面的内容？：时间局部性：如果一个存储单元被访问，那么在不久的将来它很可能再次被访问。例如，循环中的指令和数据在循环执行期间会被频繁访问。空间局部性：如果一个存储单元被访问，那么与它相邻的存储单元也很可能在不久的将来被访问。例如，数组中的元素在访问时，相邻的元素也可能被依次访问。

      4. Cache的运用为什么可以加快系统整体性能？：减少访问主存储器的时间：由于 Cache 的速度比主存储器快得多，当处理器需要访问数据时，如果数据在 Cache 中，就可以直接从 Cache 中读取，而不需要访问速度较慢的主存储器，从而大大减少了访问时间。利用局部性原理：程序的局部性特点使得 Cache 能够有效地预测哪些数据可能会被再次访问，并提前将这些数据存储在 Cache 中，提高了数据的命中率。

         ### 代码优化
         
         #### 计算斐波那契数列
         
         ##### 优化前
         
         ```
         #include <stdio.h>
         
         int fibonacci(int n) {
             if (n <= 1) {
                 return n;
             } else {
                 return fibonacci(n - 1) + fibonacci(n - 2);
             }
         }
         
         int main() {
             int n;
             printf("请输入要计算的斐波那契数列的项数：");
             scanf("%d", &n);
         
             for (int i = 0; i < n; i++) {
                 printf("%d ", fibonacci(i));
             }
         
             return 0;
         }
         ```
         
         ##### 优化后
         
         ```
         #include <stdio.h>
         
         int fibonacci(int n) {
                  if (n <= 1) return n;
                  int a = 0, b = 1, c;
                  for (int i = 2; i <= n; i++) {
                      c = a + b;
                      a = b;
                      b = c;
                  }
                  return c;
              }
              
         int main() {
             int n;
             printf("请输入要计算的斐波那契数列的项数：");
             scanf("%d", &n);
         
             for (int i = 0; i < n; i++) {
                 printf("%d ", fibonacci(i));
             }
         
             return 0;
         }
         ```
         
         ##### 原因
         
         用迭代替换递归算法，可以避免函数嵌套，当n过于大的时候，采用递归算法很容易爆栈。
         
         在学习到递归思想时，网课老师提到了这个算法有潜在的爆栈风险，所以在做到这个题的时候，我直接想到了优化递归。
         
         关于如何合理利用缓存，除了优化算法，对于频繁进行插入删除操作的程序，可以使用链表。此外，根据我对cache浅尝辄止的学习了解，还可以优化时间与空间的局部性，比如在处理二维数组时，按照行优先的顺序访问数据可以更好地利用缓存，因为在内存中二维数组是按行存储的。